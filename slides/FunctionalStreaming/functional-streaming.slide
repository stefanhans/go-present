Functional Streaming in Go
Functions and Go's CSP Model Controlling Data Streams
1 Nov 2017
Tags: go functional streams

Stefan Hans
Go Rookie and Native Speaker Wannabe
contact@stefan-hans.de
https://github.com/stefanhans/go-present/


* About Myself And Go

- doing my kind of 'research and development' of cutting-edge technology for over two years now
- doing Go programming since February 2017
- Go at the center of my way forward facing the changes of digitization yet to come
- expecting increasing demand for Go expertise in programming and ecosystem
- visioning a strategy towards a business model around Go experts
- talks on Go related topics are a part of this strategy

.image images/gopher-talks.png


* Functional Streaming?

Systems handling data streams controlled by functions is a static model. If you take functions as first-class citizens being itself part of these data streams the system becomes more dynamic.
Finally, if all basic parts of the structure like nodes and edges can be transferred within the structure the system is maximally dynamic and flexible.

In this concern, 'Functional Streaming' is build upon the simplest possible principles how to combine functional programming and the CSP model from Go.


* Agenda

- building streams with channels and functions
- collect and publish (pub/sub)
- distribute between two
- distribute between many
- buffer and flush
- fold and aggregate
- convert data types

Is that enough?

- meta channel, composites, registration, and APIs

.image images/academic_gopher.png


* Building Streams (1/4)

.code functionalstreams/node_of_int.go /START_1/,/END_1/
.code functionalstreams/node_of_int.go /START_2/,/END_2/


* Building Streams (2/4)

.code functionalstreams/node_of_int.go /START_3/,/END_3/
Helper function to trigger input
.code functionalstreams/util_of_int.go /START_3/,/END_3/


* Building Streams (3/4)

Connects the output of a node with the input of another
.code functionalstreams/node_of_int.go /START_5/,/END_5/

Exchange the function of a node
.code functionalstreams/node_of_int.go /START_SETFUNC/,/END_SETFUNC/

Helper function to show output
.code functionalstreams/util_of_int.go /START_2/,/END_2/


* Building Streams (4/4)

.play -edit sn_connect.go /func main/,/^}/


* Anonymous Nodes

No need to change the function later? Encapsulate the node within a function.
.code functionalstreams/node_of_int.go /START_CALC/,/END_CALC/
.play -edit sn_calculate.go /func main/,/^}/


* Collect Streams (1/2)

Collecting streams seems to be easy but it can lead to deadlocks
.play -edit sn_collector_bug.go /func main/,/^}/
Increase the buffer of the out channels as a workaround or wait with sending until structure is established.


* Collect Streams (2/2)

.play -edit sn_collector.go /func main/,/^}/


* Publish Streams (1/5)

Publishing streams is more sophisticated
.code functionalstreams/publisher_of_int.go /START_SUBSCRIPTION/,/END_SUBSCRIPTION/
.code functionalstreams/publisher_of_int.go /START_1/,/END_1/


* Publish Streams (2/5)

.code functionalstreams/publisher_of_int.go /START_2/,/END_2/


* Publish Streams (3/5)

.code functionalstreams/publisher_of_int.go /START_3/,/END_3/


* Publish Streams (4/5)
.code functionalstreams/publisher_of_int.go /START_4/,/END_4/


* Publish Streams (5/5)

.play -edit sn_publisher.go /START_6/,/END_6/


* Tee Streams (1/2)

.code functionalstreams/distributor_of_int.go /START_TEE/,/END_TEE/

* Tee Streams (2/2)

.play -edit sn_tee.go /func main/,/^}/


* Anonymous Filter (1/2)

.code functionalstreams/distributor_of_int.go /START_FILTER/,/END_FILTER/


* Anonymous Filter (2/2)

.play -edit sn_filter.go /func main/,/^}/


* Anonymous Switch (1/2)

.code functionalstreams/distributor_of_int.go /START_SWITCH/,/END_SWITCH/

* Anonymous Switch (2/2)

.play -edit sn_switch.go /func main/,/^}/


* Distribute to All or Round-Robin (1/2)

.code functionalstreams/distributor_of_int.go /START_TOALL/,/END_TOALL/
.code functionalstreams/distributor_of_int.go /START_RR/,/END_RR/

* Distribute to All or Round-Robin (2/2)

.play -edit sn_round_robin.go /func main/,/^}/


* Buffer and Flush (1/5)

.code functionalstreams/buffer_of_int.go /START_1/,/END_1/
.code functionalstreams/buffer_of_int.go /START_3/,/END_3/


* Buffer and Flush (2/5)

.code functionalstreams/buffer_of_int.go /START_2/,/END_2/


* Buffer and Flush (3/5)
Values will be buffered and flushed
.code functionalstreams/buffer_of_int.go /START_BUFFER/,/END_BUFFER/
.code functionalstreams/buffer_of_int.go /START_FLUSH/,/END_FLUSH/
Set a control function using input, length, and capacity of the buffer
.code functionalstreams/buffer_of_int.go /START_FUNC/,/END_FUNC/


* Buffer and Flush (4/5)

.play -edit sn_buffer.go /func main/,/^}/


* Buffer and Flush (5/5)

.play -edit sn_buffer_func.go /START_BUFFUNC/,/END_BUFFUNC/


* Fold (1/3)

.code functionalstreams/folder_of_int.go /START_1/,/END_1/
.code functionalstreams/folder_of_int.go /START_3/,/END_3/


* Fold (2/3)

.code functionalstreams/monad_of_int.go /START_1/,/END_1/
.code functionalstreams/monad_of_int.go /START_2/,/END_2/
.code functionalstreams/folder_of_int.go /START_2/,/END_2/


* Fold (3/3)

.code functionalstreams/folder_of_int.go /START_RESULT/,/END_RESULT/
.play -edit /sn_folder.go /func main/,/^}/


* Aggregate (1/3)

.code functionalstreams/aggregator_of_int.go /START_1/,/END_1/
.code functionalstreams/aggregator_of_int.go /START_3/,/END_3/


* Aggregate (2/3)

.code functionalstreams/aggregator_of_int.go /START_2/,/END_2/
.code functionalstreams/aggregator_of_int.go /START_RESET/,/END_RESET/


* Aggregate (3/3)

.play -edit sn_aggregator.go /func main/,/^}/


* Some Practical Tips

- use the race option
	$ go run -race <go file>
- do not forget make()
- use select
- use go routines to avoid blocking

.image images/project.png


* Forecast

Ideas for Talks

- Functional Streaming in Distributed Systems

- Reactive Systems with Functional Streaming

- Functional Streaming and Machine Learning

.image images/pkg.png



