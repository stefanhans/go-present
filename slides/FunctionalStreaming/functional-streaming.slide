Functional Streaming in Go
Functions and Go's CSP Model Controlling Data Streams
2 Nov 2017
Tags: go functional streams

Stefan Hans
Go Rookie and Native Speaker Wannabe
contact@stefan-hans.de
https://github.com/stefanhans/go-present/


* About Myself And Go

- doing my kind of 'research and development' of cutting-edge technology for over two years now
- doing Go programming since February 2017
- expecting increasing demand for Go expertise in programming and ecosystem
- visioning a strategy towards a business model around Go experts
- talks on Go related topics are a part of this strategy

.image images/gopher-talks.png


* Agenda

- introducing the core principles
- building streams with channels and functions
- collect and publish (pub/sub)
- distribute between two
- distribute between many
- buffer and flush
- fold and aggregate
- convert data types statically

Is that enough?

- meta channel, composites, registration, and APIs


* The core principles of 'Functional Streaming' as I mean it

- node-like structs with one main loop are the basic parts handling data streams
- functions called in the main loop control or transform the data streams
- crucial parts of structs and main loops, respectively, can be exchanged during handling data streams
- elements can exchange meta information and act on it

.image images/project.png

Let's see what can we achieve with these ideas in a first attempt.


* Building Streams (1/4)

.code functionalstreams/node_of_int.go /START_1/,/END_1/
.code functionalstreams/node_of_int.go /START_2/,/END_2/


* Building Streams (2/4)

.play -edit sn_connect.go /func main/,/^}/

Best to implement in the following order:

1st: finish node creation
2nd: finish stream configuration
3rd: start sending data
4th: change function via channel (optional)


* Building Streams (3/4)

.code functionalstreams/node_of_int.go /START_3/,/END_3/
Helper function to trigger input
.code functionalstreams/util_of_int.go /START_3/,/END_3/


* Building Streams (4/4)

Connects the output of a node with the input of another
.code functionalstreams/node_of_int.go /START_5/,/END_5/

Exchange the function of a node
.code functionalstreams/node_of_int.go /START_SETFUNC/,/END_SETFUNC/

Helper function to show output
.code functionalstreams/util_of_int.go /START_2/,/END_2/


* Anonymous Nodes

No need to change the function later? Encapsulate the node within a function.
.code functionalstreams/node_of_int.go /START_CALC/,/END_CALC/
.play -edit sn_calculate.go /func main/,/^}/

The node which is following *node_1* is anonymous and not accessible


* Collect Streams

Collecting streams is easy
.play -edit sn_collector.go /func main/,/^}/


* Publish Streams (1/5)

Publishing streams is more sophisticated
.code functionalstreams/publisher_of_int.go /START_SUBSCRIPTION/,/END_SUBSCRIPTION/
.code functionalstreams/publisher_of_int.go /START_1/,/END_1/


* Publish Streams (2/5)

.code functionalstreams/publisher_of_int.go /START_2/,/END_2/


* Publish Streams (3/5)

.code functionalstreams/publisher_of_int.go /START_3/,/END_3/


* Publish Streams (4/5)
.code functionalstreams/publisher_of_int.go /START_4/,/END_4/


* Publish Streams (5/5)

.play -edit sn_publisher.go /START_6/,/END_6/


* Tee Streams (1/2)

.code functionalstreams/distributor_of_int.go /START_TEE/,/END_TEE/

* Tee Streams (2/2)

.play -edit sn_tee.go /func main/,/^}/


* Anonymous Filter (1/2)

.code functionalstreams/distributor_of_int.go /START_FILTER/,/END_FILTER/


* Anonymous Filter (2/2)

.play -edit sn_filter.go /func main/,/^}/


* Anonymous Switch (1/2)

.code functionalstreams/distributor_of_int.go /START_SWITCH/,/END_SWITCH/

* Anonymous Switch (2/2)

.play -edit sn_switch.go /func main/,/^}/


* Distribute to All or Round-Robin (1/2)

.code functionalstreams/distributor_of_int.go /START_TOALL/,/END_TOALL/
.code functionalstreams/distributor_of_int.go /START_RR/,/END_RR/

* Distribute to All or Round-Robin (2/2)

.play -edit sn_round_robin.go /func main/,/^}/


* Buffer and Flush (1/5)

.code functionalstreams/buffer_of_int.go /START_1/,/END_1/
.code functionalstreams/buffer_of_int.go /START_3/,/END_3/


* Buffer and Flush (2/5)

.code functionalstreams/buffer_of_int.go /START_2/,/END_2/


* Buffer and Flush (3/5)
Values will be buffered and flushed
.code functionalstreams/buffer_of_int.go /START_BUFFER/,/END_BUFFER/
.code functionalstreams/buffer_of_int.go /START_FLUSH/,/END_FLUSH/
Set a control function using input, length, and capacity of the buffer
.code functionalstreams/buffer_of_int.go /START_FUNC/,/END_FUNC/


* Buffer and Flush (4/5)

.play -edit sn_buffer.go /func main/,/^}/


* Buffer and Flush (5/5)

.play -edit sn_buffer_func.go /START_BUFFUNC/,/END_BUFFUNC/


* Fold (1/3)

.code functionalstreams/folder_of_int.go /START_1/,/END_1/
.code functionalstreams/folder_of_int.go /START_3/,/END_3/


* Fold (2/3)

.code functionalstreams/monad_of_int.go /START_1/,/END_1/
.code functionalstreams/monad_of_int.go /START_2/,/END_2/
.code functionalstreams/folder_of_int.go /START_2/,/END_2/


* Fold (3/3)

.code functionalstreams/folder_of_int.go /START_RESULT/,/END_RESULT/
.play -edit sn_folder.go /func main/,/^}/


* Aggregate (1/3)

.code functionalstreams/aggregator_of_int.go /START_1/,/END_1/
.code functionalstreams/aggregator_of_int.go /START_3/,/END_3/


* Aggregate (2/3)

.code functionalstreams/aggregator_of_int.go /START_2/,/END_2/
.code functionalstreams/aggregator_of_int.go /START_RESET/,/END_RESET/


* Aggregate (3/3)

.play -edit sn_aggregator.go /func main/,/^}/


* Convert Statically (1/3)

.code functionalstreams/converter_int_to_float.go /START_1/,/END_1/
.code functionalstreams/converter_int_to_float.go /START_3/,/END_3/


* Convert Statically (2/3)

.code functionalstreams/converter_int_to_float.go /START_2/,/END_2/
.code functionalstreams/node_of_int.go /START_CONNECTCONVERTER/,/END_CONNECTCONVERTER/
.code functionalstreams/converter_int_to_float.go /START_CONNECT/,/END_CONNECT/


* Convert Statically (3/3)

.play -edit sn_converter_int_to_float.go /func main/,/^}/


* Some Practical Tips

- use the race option
	$ go run -race <go file>
- do not forget make()
- use select
- use go routines to avoid blocking

.image images/project.png


* Forecast

Ideas for Talks

- Functional Streaming in Distributed Systems

- Reactive Systems with Functional Streaming

- Functional Streaming and Machine Learning

.image images/pkg.png



