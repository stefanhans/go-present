Higher-Order Functions in Go
9 Apr 2017
Tags: go functional

Stefan Hans
Go Rookie and Native Speaker Wannabe
contact@stefan-hans.de
https://github.com/stefanhans/go-present/

* A Little Theory at First

- functions as first-class citizens, i.e. as types
- immutable state
- functional and pure functional programming
- monads
- lazy lists as types defined by functions (Hindleyâ€“Milner)

.image images/academic_gopher.png

* Higher-Order Functions in Go

Go does not supports higher-order functions like map, filter or fold

Go does not support generics - no sufficient compiler approach found yet

.link https://docs.google.com/document/d/1V03LUfjSADDooDMhe-_K59EgpTEm3V8uvQRuNMAEnjg/edit Go generate: A Proposal

.image images/gopher-talks.png

_"If_a_language_has_too_many_features,_you_waste_time_choosing_which_ones_to_use._
_Then_implement,_refine,_possibly_rethink_and_redo."_

Rob Pike, _Simplicity_is_Complicated_

* Simple Map Function (1/2)

.code hof/map.go

* Simple Map Function (2/2)

.play -edit map_use.go


* Simple Filter Function (1/2)

.code hof/filter.go

* Simple Filter Function (2/2)

.play -edit filter_use.go

* Currying Function

.play -edit currying.go

* Fold Function Approach

.play -edit fold_approach.go

* Fold Function With Monads (1/2)

Monad laws (simplified):

- neutral element
- associative function

.code hof/fold.go

* Fold Function With Monads (2/2)

.play -edit monad.go

Why should the function be associative?

* Simple High-Order Function As Reference Method

	func (list *ListOfInt) RefMap(f listMapFunc) {
		for i := 0; i < len(*list); i++ {
			(*list)[i] = f((*list)[i])
		}
	}

.play -edit ref_map_use.go

* Parallel High-Order Function As Reference Method (1/2)
Helper function

	func (list *ListOfInt) chanRefMap(f listMapFunc, from, to int, c chan<- bool) {
		for i := from; i < to; i++ {
			(*list)[i] = f((*list)[i])
		}
		c <- true
	}

Exported function

	func (list *ListOfInt) ParRefMap(f listMapFunc, cores int) {
		var from, to int
		c := make(chan bool)
		batchSize := int(math.Ceil(float64(len(*list)) / float64(cores)))
		for i := 0; i < cores; i++ {
			to = int(math.Min(float64(from+batchSize), float64(len(*list))))
			go list.chanRefMap(f, from, to, c)
			from = to
		}
		for i:=0; i<cores; i++ { <-c }
	}

* Parallel High-Order Function As Reference Method (2/2)

.play -edit par_ref_map_use.go


* Parallel High-Order Function With Internal Reference Method (1/2)

Using chanRefMap as helper function on an internal copy

	func (list ListOfInt) PMap(f listMapFunc, cores int) ListOfInt {

		// Create internal copy
		out := make(ListOfInt, len(list))
		copy(out, list)

		c := make(chan bool)
		var from, to int
		batchSize := int(math.Ceil(float64(len(out)) / float64(cores)))
		for i := 0; i < cores; i++ {
			to = int(math.Min(float64(from+batchSize), float64(len(out))))
			go (&out).chanRefMap(f, from, to, c)
			from = to
		}
		for i := 0; i < cores; i++ {
			<-c
		}
		return out
	}

* Parallel High-Order Function With Internal Reference Method (2/2)

.play -edit pmap_use.go

* Lazy Lists Defined by Function (1/2)

	type FloatMonad struct {
		NeutralElement float64
		AssocFunc      func(float64) float64
	}
	type LazyListOfFloat struct {
		Monad FloatMonad
		floats []float64
		last float64
	}
	func(list *LazyListOfFloat) Next() float64 {
		if list.floats == nil {
			list.last = list.Monad.NeutralElement
		} else {
			list.last = list.Monad.AssocFunc(list.last)
		}
		list.floats = append(list.floats, list.last)
		return list.last
	}
	func(list *LazyListOfFloat) Get(ord int) float64 {
		for i:=len(list.floats);  i<ord; i++ {
			list.Next()
		}
		return list.floats[ord-1]
	}

* Lazy Lists Defined by Function (2/2)

.play -edit lazy_list_use.go

* Links
dotGo 2015 - Francesc Campoy Flores - Functional Go?
.link https://www.youtube.com/watch?v=ouyHp2nJl0I&t=118s https://www.youtube.com/watch?v=ouyHp2nJl0I&t=118s
A concurrent prime sieve (The Go Playground)
.link https://play.golang.org/p/9U22NfrXeq https://play.golang.org/p/9U22NfrXeq





