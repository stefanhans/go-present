Advanced Higher-Order Functions in Go
28 August 2017
Tags: go functional

Stefan Hans
Go Rookie and Native Speaker Wannabe
contact@stefan-hans.de
https://github.com/stefanhans/go-present/


* About Myself And Go

- research and development on cutting-edge technology for over two years now
- doing Go programmming since February 2017
- found Go at the center of my way forward facing the changes of digitization yet to come
- expecting increasing demand for Go expertises in programming and ecosystem
- visioning a strategy towards a business model around Go experts
- talks about Go related topics is a part of this strategy

.image images/academic_gopher.png


* Higher-Order Functions With Data Structures

- map and filter - simple higher-order functions
- mutable and immutable data structures
- parallel executions
- monads - a function type may be not enough
- zip and groupBy - more complex transformations
- monads and the empty interface - kind of generics in Go

.image images/academic_gopher.png

* Simple Map Function

.code adv_map.go /START/,/END/

.play -edit adv_map.go /func main/,/^}/


* Simple Filter Function

.code adv_filter.go /START/,/END/

.play -edit adv_filter.go /func main/,/^}/


* Simple Fold Function

.code adv_fold.go /START/,/END/

.play -edit adv_fold.go /func main/,/^}/


* Higher-Order Function Chain

.play -edit adv_chain.go /func main/,/^}/

We can create simple higher-order functions with immutable states chaining them together.
Let's have a look now at mutability and immutability, respectively, and at parallelism applied to a simple mapping function.

* Serial Map Function With Mutable State

.code ref_map.go /START/,/END/

.play -edit ref_map.go /func main/,/^}/


* Parallel Map Function With Mutable State (1/2)

Internal helper function

.code par_ref_map.go /chanMap/,/^}/

Exported function

.code par_ref_map.go /ParMap/,/^}/

* Parallel Map Function With Mutable State (2/2)

.play -edit par_ref_map.go /func main/,/^}/


* Parallel Map Function With Immutable State (1/2)

Using chanMap as helper function on an internal copy

.code pmap.go /ParMap/,/^}/

* Parallel Map Function With Immutable State (2/2)

.play -edit pmap.go /func main/,/^}/

* Monads (simplified)

A data type wrapped around a function following two rules:

- neutral element
	f(n, x) = x

- associative function
	f(f(x, y), z) = f(x, f(y, z))

Associativity is not commutativity. The string concatenation and the product of square matrices are examples.


* Fold Function With Monads (1/2)

.code monad.go /START/,/END/

* Fold Function With Monads (2/2)

.play -edit monad.go /func main/,/^}/

Why should the function be associative?


* Simple Zip Function

.code zip.go /START/,/END/

.play -edit zip.go /func main/,/^}/



* Simple GroupBy Function

.code group.go /START/,/END/

.play -edit group.go /func main/,/^}/


* Monads and Interfaces (1/3)

Slice of empty interfaces as generic list

.code staticEmptyInterfaceListFold.go /START_IF/,/END_IF/

Monad struct for handling empty interfaces

.code staticEmptyInterfaceListFold.go /START_IMPL/,/END_IMPL/

Generic Fold function

.code staticEmptyInterfaceListFold.go /START_FOLD/,/END_FOLD/

* Monads and Interfaces (2/3)

.play -edit staticEmptyInterfaceListFold.go /func main/,/^}/

* Monads and Interfaces (3/3)

.code dynamicEmptyInterfaceListFold.go /START_FOLD/,/END_FOLD/

.play -edit dynamicEmptyInterfaceListFold.go /func main/,/^}/


* Group Structs By Functions (1/3)

.code groupStructs.go /DEF_START/,/DEF_END/


* Group Structs By Functions (2/3)

.code groupStructs.go /STRUCT_START/,/STRUCT_END/


* Group Structs By Functions (3/3)

.play -edit groupStructs.go /RUN_START/,/RUN_END/


* Aspects of Higher-Order Functions

Dimensions

- Input and output data structures
- Function arguments and return values

Execution

- Parallelism
- State

Aspects related to parallelism

- Monad
- Join function

* Lazy Lists Defined by Function (1/3)

.code lazy_list.go /FloatDef/,/^}/

.code lazy_list.go /LazyListOfFloat/,/^}/

* Lazy Lists Defined by Function (2/3)

.code lazy_list.go /Next/,/^}/

.code lazy_list.go /Get/,/^}/

* Lazy Lists Defined by Function (3/3)

.play -edit lazy_list.go /func main/,/^}/
